'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = ReactTimeAgo;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _javascriptTimeAgo = require('javascript-time-ago');

var _javascriptTimeAgo2 = _interopRequireDefault(_javascriptTimeAgo);

var _propTypes3 = require('javascript-time-ago/prop-types');

var _verboseDateFormatter = require('./helpers/verboseDateFormatter');

var _verboseDateFormatter2 = _interopRequireDefault(_verboseDateFormatter);

var _date = require('./helpers/date');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var MINUTE = 60 * 1000;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = 30 * DAY;
var YEAR = 365 * DAY;

// For standard `timeStyle`s, "smart" autoupdate interval is used:
// every minute for the first hour, then every 10 minutes for the first 12 hours, and so on.
// "Smart" autoupdate intervals should be moved to `javascript-time-ago`'s grading scale.
var INTERVALS = [{
	interval: MINUTE
}, {
	threshold: HOUR,
	interval: 10 * MINUTE
}, {
	threshold: 12 * HOUR,
	interval: 20 * MINUTE
}, {
	threshold: DAY,
	interval: 3 * HOUR
}, {
	threshold: 7 * DAY,
	interval: 6 * HOUR
}, {
	threshold: MONTH,
	interval: 5 * DAY
}, {
	threshold: 3 * MONTH,
	interval: 10 * DAY
}, {
	threshold: YEAR,
	interval: MONTH
}];

// `setTimeout()` would enter an infinite cycle when interval is a `MONTH`.
// https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values
var SET_TIMEOUT_MAX_DELAY = 2147483647;

function ReactTimeAgo(_ref) {
	var date = _ref.date,
	    timeStyle = _ref.timeStyle,
	    tooltip = _ref.tooltip,
	    container = _ref.container,
	    locale = _ref.locale,
	    locales = _ref.locales,
	    formatVerboseDate = _ref.formatVerboseDate,
	    verboseDateFormat = _ref.verboseDateFormat,
	    updateInterval = _ref.updateInterval,
	    tick = _ref.tick,
	    rest = _objectWithoutProperties(_ref, ['date', 'timeStyle', 'tooltip', 'container', 'locale', 'locales', 'formatVerboseDate', 'verboseDateFormat', 'updateInterval', 'tick']);

	// Composes a list of preferred locales
	var preferredLocales = (0, _react.useMemo)(function () {
		// Convert `locale` to `locales`.
		if (locale) {
			locales = [locale];
		}
		// `javascript-time-ago` default locale.
		return locales.concat(_javascriptTimeAgo2.default.getDefaultLocale());
	}, [locale, locales]);

	// Create `javascript-time-ago` formatter instance.
	var timeAgo = (0, _react.useMemo)(function () {
		return new _javascriptTimeAgo2.default(preferredLocales);
	}, [preferredLocales]);

	// Create verbose date formatter for the tooltip text.
	// (only on client side, because tooltips aren't rendered until triggered)
	var verboseDateFormatter = (0, _react.useMemo)(function () {
		if (typeof window !== 'undefined') {
			return (0, _verboseDateFormatter2.default)(preferredLocales, verboseDateFormat);
		}
	}, [preferredLocales, verboseDateFormat]);

	var _useState = (0, _react.useState)(),
	    _useState2 = _slicedToArray(_useState, 2),
	    unusedState = _useState2[0],
	    setUnusedState = _useState2[1];

	var forceUpdate = (0, _react.useCallback)(function () {
		return setUnusedState({});
	}, [setUnusedState]);

	var autoUpdateTimer = (0, _react.useRef)();

	var getNextAutoUpdateDelay = (0, _react.useCallback)(function () {
		// "Smart" autoupdate intervals are only used for standard time styles.
		if ((typeof timeStyle === 'undefined' ? 'undefined' : _typeof(timeStyle)) === 'object') {
			return updateInterval;
		}
		var time = (0, _date.getTime)(date);
		var now = Date.now();
		var diff = Math.abs(now - time);
		var _interval = void 0;
		for (var _iterator = INTERVALS, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
			var _ref2;

			if (_isArray) {
				if (_i >= _iterator.length) break;
				_ref2 = _iterator[_i++];
			} else {
				_i = _iterator.next();
				if (_i.done) break;
				_ref2 = _i.value;
			}

			var _ref3 = _ref2,
			    interval = _ref3.interval,
			    threshold = _ref3.threshold;

			if (threshold && diff < threshold) {
				continue;
			}
			_interval = interval;
		}
		return Math.min(_interval, SET_TIMEOUT_MAX_DELAY);
	}, [date, timeStyle, updateInterval]);

	var scheduleNextTick = (0, _react.useCallback)(function () {
		// Register for the relative time autoupdate as the time goes by.
		autoUpdateTimer.current = setTimeout(function () {
			forceUpdate();
			scheduleNextTick();
		}, getNextAutoUpdateDelay());
	}, [forceUpdate, getNextAutoUpdateDelay]);

	// Verbose date string.
	// Is used as a tooltip text.
	//
	// E.g. "Sunday, May 18th, 2012, 18:45"
	//
	var getVerboseDate = (0, _react.useCallback)(function (input) {
		var date = convertToDate(input);
		if (formatVerboseDate) {
			return formatVerboseDate(date);
		}
		return verboseDateFormatter(date);
	}, [formatVerboseDate, verboseDateFormatter]);

	var isMounted = (0, _react.useRef)();

	(0, _react.useEffect)(function () {
		isMounted.current = true;
		// If time label autoupdates are enabled.
		if (tick) {
			scheduleNextTick();
		}
		return function () {
			clearTimeout(autoUpdateTimer.current);
		};
	}, []);

	// The date or timestamp that was passed.
	// Convert timestamp to `Date`.
	date = (0, _date.getDate)(date);

	// Format verbose date for the tooltip.
	// (only on client side, because tooltips aren't rendered until triggered)
	var verboseDate = typeof window === 'undefined' ? undefined : getVerboseDate(date);

	var timeElement = _react2.default.createElement(
		'time',
		_extends({
			dateTime: date.toISOString(),
			title: tooltip ? verboseDate : undefined
		}, rest),
		timeAgo.format(date, timeStyle)
	);

	if (container) {
		return _react2.default.createElement(container, _extends({
			verboseDate: verboseDate
		}, rest), timeElement);
	}

	return timeElement;
}

ReactTimeAgo.propTypes = {
	// The `date` or `timestamp`.
	// E.g. `new Date()` or `1355972400000`.
	date: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(Date), _propTypes2.default.number]).isRequired,

	// Preferred locale.
	// Is 'en' by default.
	// E.g. 'ru-RU'.
	locale: _propTypes2.default.string,

	// Preferred locales (ordered).
	// Will choose the first suitable locale from this list.
	// (the one that has been initialized)
	// E.g. `['ru-RU', 'en-GB']`.
	locales: _propTypes2.default.arrayOf(_propTypes2.default.string),

	// Date/time formatting style.
	// E.g. 'twitter', 'time', or custom (`{ gradation: […], units: […], flavour: 'long', custom: function }`)
	timeStyle: _propTypes3.style,

	// Whether HTML `tooltip` attribute should be set
	// to verbosely formatted date (is `true` by default).
	// Set to `false` to disable the native HTML `tooltip`.
	tooltip: _propTypes2.default.bool.isRequired,

	// An optional function returning what will be output in the HTML `title` tooltip attribute.
	// (by default it's `(date) => new Intl.DateTimeFormat(locale, {…}).format(date)`)
	formatVerboseDate: _propTypes2.default.func,

	// `Intl.DateTimeFormat` format for the HTML `title` tooltip attribute.
	// Is used when `formatVerboseDate` is not specified.
	// By default outputs a verbose date.
	verboseDateFormat: _propTypes2.default.object,

	// How often to update all `<ReactTimeAgo/>` elements on a page.
	// (is once in a minute by default)
	// This setting is only used for "custom" `timeStyle`s.
	// For standard `timeStyle`s, "smart" autoupdate interval is used:
	// every minute for the first hour, then every 10 minutes for the first 12 hours, and so on.
	updateInterval: _propTypes2.default.number,

	// Set to `false` to disable automatic refresh of
	// `<ReactTimeAgo/>` elements on a page as time goes by.
	// (is `true` by default)
	tick: _propTypes2.default.bool,

	// React Component to wrap the resulting `<time/>` React Element.
	// Receives `verboseDate` and `children` properties.
	// `verboseDate` can be used for displaying verbose date label
	// in an "on mouse over" (or "on touch") tooltip.
	//
	// ```js
	// import React from 'react'
	// import ReactTimeAgo from 'react-time-ago'
	// import { Tooltip } from 'react-responsive-ui'
	// 
	// export default function TimeAgo(props) {
	//   return <ReactTimeAgo {...props} container={Container} tooltip={false}/>
	// }
	// 
	// const Container = ({ verboseDate, children }) => (
	//   <Tooltip content={verboseDate}>
	//     {children}
	//   </Tooltip>
	// )
	// ```
	//
	container: _propTypes2.default.func
};

ReactTimeAgo.defaultProps = {
	// No preferred locales.
	locales: [],

	// Show verbose date `title` tooltip on mouse over.
	tooltip: true,

	// Thursday, December 20, 2012, 7:00:00 AM GMT+4
	verboseDateFormat: {
		weekday: 'long',
		day: 'numeric',
		month: 'long',
		year: 'numeric',
		hour: 'numeric',
		minute: '2-digit',
		second: '2-digit'
		// timeZoneName : 'short'
	},

	// Updates once a minute
	updateInterval: MINUTE,

	// Refreshes time in a web browser by default
	tick: true

	// Converts argument into a `Date`.
};function convertToDate(input) {
	if (input.constructor === Date || (0, _date.isMockedDate)(input)) {
		return input;
	}
	if (typeof input === 'number') {
		return new Date(input);
	}
	throw new Error('Unsupported react-time-ago input: ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input)) + ', ' + input);
}
//# sourceMappingURL=ReactTimeAgo.js.map